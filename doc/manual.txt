Data model Generator
====================

This tool provides any easy way to generate C++ code from a pseudo language that describes
data read from a binary source and usable models classes.

It is related to O3D types, but it can be easily modified to support more standards
types, or more specifics (to your own library).

Usage : dmg <path>

Path is where to find the datamodelgen file, and base path for any relative path found
in the datamodelgen file. The content of datamodelgen is describes below of this
document.


++++++
Target
++++++

A target is the displayer or the authority.


+++++++++++++++++++
Language definition
+++++++++++++++++++

.dmg is the extension for the source files. Only *.dmg files are parsed.

# define a comment line
data keyword to define a generated message
abstract keyword define an abstract (non generated data model)
import keyword define a name of a data model file to import (without the .dmg extension)

A <Name> contain letters, and numerical, and _, like in C/C++.

Example:
	# a data model
	import BaseData

	data MyData<13> : BaseData
	{
		public const uint32 DEFAULT_VALUE = 3

		identifier int32 m_id

		int8 m_age
		bool m_sex
		string m_name
		
		int8[4] m_specificities
	}

A file can contain many messages, many abstracts messages, many comments lines,
and many import directives.

Each file mean a related set of exported file for the targets.
If you want one class in one specific file per data model you have to write only one
data model per file.


--------------
data datamodel
--------------

data <NAME><optional\<INTEGER\>><:NAME>
{
	<private|protected|public> const <expression> = <constant>

	target <displayer|authority|editor>
	{
		@identifier headers = <header1, ...>
		@identifier manager = "<getter_method_of_the_manager>"
		@identifier method = <*,><method>(<parameters>, <$id>)

		<expressions...>
	}

	identifier <expression>

	<expressions...>
}

A data model have a unique name, and its code is auto-generated by incrementing a global
counter. But it is possible to set some data model code manualy in <INTEGER>.

Example: data MyData<13>

Inheritance is possible using the : after the data model name and <code>.
The inherit data must exist in the file, or be imported using the import directive.

Example: msg MyData<13> : BaseData

The inherited message can be a data or an abstract.

indentifier define what field is used to identify the message by the factory.
There is only one indentifier per model and per inheritance.

A data model generate a class, with getters, setters, read, write, finalize and
post import methods. The class name is NameOfTheData. The methods differs from
the target (displayer, authority, editor).

Getters are auto-generated on data models, for each variable, conditions, loop,
as the readFromFile, and finalize method. The postImport method is generated for
the displayer and authority targets, in a <data>.user.<cppext> file. This content of the
postImport method is keept during regeneration of the data models.

Setter are auto-generated on the editor target, as the writeToFile method.

Generated files are :

 - DataModelName.<hppext>
 - DataModelName.<hppext>
 - DataModelName.user.<cppext>
 

-------
targets
-------

There are 3 targets :
	- displayer Is generaly the client whoose have the capacity of displaying the resource.
	- authority Is generaly the server.
	- editor Is a special target having the capacity of writing the data content.

Except editor the two others targets have read only access to the data content.
It is possible to specify some expression per target using the target <target_name> {} block.

Also this block defines 3 anotations working on the identifier object.
They always starts by : 

	@identifier <headers, manager, method> = <expression>

+++++++
headers
+++++++

===============================
/!\ TODO DOCUMENT THIS PART /!\
===============================

+++++++
manager
+++++++

===============================
/!\ TODO DOCUMENT THIS PART /!\
===============================

++++++
editor
++++++

===============================
/!\ TODO DOCUMENT THIS PART /!\
===============================


+++++++++++++++++++++
Members into a target
+++++++++++++++++++++

===============================
/!\ TODO DOCUMENT THIS PART /!\
===============================


-------------------
abstract data model
-------------------

An abstract is never exported, it only can be used for inheritance.
Example:
 abstract BaseData
 {
 	int8 type
 }


-----------------------------------
expressions, core of the data model
-----------------------------------

A data model can contain different type of expressions :

- constants (const, public const <NAME|INTEGER>, bit)
- variables (with or without template, reference or object)
- conditions (boolean test if)
- loops (named loop)


-----
types
-----

Constants, and variables are typed :

- bool Boolean
- int8, uint8 signed, unsigned 1 byte
- int16, uint16
- int32, uint32
- int64, uint64
- float, 4 bytes float
- double, 8 bytes double
- string, utf8 sized string
- bitset8, bitset16, bitset32, bitset64, bit field size on a byte, 2, 4 and 8
- array8, dynamic array of bytes
- <TYPENAME>[], static array of typename (example: int8[4] forBytes)

Custom types are supported by adding tdg files and a using directive into the dmg files.

++++++++++++++++++++++
custom type definition
++++++++++++++++++++++

Custom type use the implementation of an existing class into you project.
First, typedef is the keyword to defines a such customisation, followed by a choosen name.

The content of a typedef object is defined by :
 - header Location of the header containing the class
 - class Namespaced if necessary, the classe name into your API

Example:
	# Declaration of a type
	typedef Rect2i
	{
		header <o3d/core/Rect2.h>
	class o3d::Rect2i
	}

In this we defines a new type name Rect2i (name used into data models) that is refering
to the o3d::Rect2i class, located into <o3d/core/Rect2.h>.

In way to use a such typedef, it is necessary to import it with the using keyword into the
header of a dmg file.

Example:
	# GeometricObject
	using type.Rect2i
	import Object

	data GeometricObject
	{
		int32 m_area
	Rect2i m_baseArea
	}

+++++++++++++++++++++++++++++++
data model as type or reference
+++++++++++++++++++++++++++++++

A defined data model can be used as a type. In reference or object, with or without template,
or as array of this type.

===============================
/!\ TODO DOCUMENT THIS PART /!\
===============================


---------
constants
---------

<public> const <TYPENAME> <NAME> = <LITTERAL|IMMEDIATE>
bit <NAME>[LITTERAL]


const
-----

A const can be public.
Examples:
  public const int8 MyConst = 4
  const int32 AConst = GENDER

A const typename can be a simple type (u)int(n), float or double, or string.
The value of the const can be a litteral or an immediate.

A litteral mean a name, and the value is an auto-generated integer, relative to its scope.
An immediate value must be a integer, float, double or string.


bit
---

A bit is always private, and it is related to an existing bitset<n>.
Example: bit myFlags[FRIEND]

The value is auto-generated by the bitset, and is unique.


---------
variables
---------

A variable generate private members in the class of the data model.

===============================
/!\ TODO DOCUMENT THIS PART /!\
===============================


-----
loops
-----

Loops are simples iterations, for 0 to n, and loops are named, causing the generation of
a struct, and a scope.

Example:
	int8 counter
	loop Friend : counter
	{
		string name
		int8 affinity	
	}
	
A struct Friend is created, and contain the name and affinity variables.
For each value of the counter, a Friend is read/write.

You can have conditions in loop, but no loops in a loop.


----------
conditions
----------


if
--

if is a simple true/false condition.
It works with any variables, 1 meaning true, 0 meaning false.
It works too with bitset like this :

Example:
	if myBitSet[HAVE_FRIENDS]
	{
		int8 counter
		loop Friend : int8 m_counter
		{
			string name
			int8 affinity	
		}
	}
	
Will create a const named HAVE_FRIENDS, with an auto-generated value for the myBitSet
bitset. In run method you can check for a bit using HAVE_FRIENDS constants on the bitset
member.

It works too with static and dynamic array. In this case the [VALUE] mean the index
into the array.

Another example:
	bool condition
	if condition
	{
		...
	}
	
It test if condition equal 1, if true, it go inside the condition.

You can have conditions and loop in if.


-------------------
template data model
-------------------

Is is possible to have data model template declaration and type specialization.

===============================
/!\ TODO DOCUMENT THIS PART /!\
===============================

Example:
	# Base data
	data Base
	{
		public const uint32 TYPE_A = 0
		public const uint32 TYPE_B = 1
		public const uint32 TYPE_C = 2

		identifier int32 m_id
		string m_name
	}

	# Category object
	import Base

	template <CAT>
	data Category : Base
	{
		uint32 m_type = CAT
	}

	# Object data
	import Base
	import Category

	template <TYPE, CAT>
	data Object : Base
	{
		uint32 m_type = TYPE

		# A template category
		Category<CAT>& m_category
	}

	# GeometricObject
	using type.Rect2i
	import Object

	data GeometricObject : Object<TYPE_A, TYPE_A>
	{
		int32 m_area
		Rect2i m_baseArea
	}



---------------------
target specialisation
---------------------

===============================
/!\ TODO DOCUMENT THIS PART /!\
===============================


+++++++++++++++++++++++++++++++
datamodelgen configuration file
+++++++++++++++++++++++++++++++

The path must contain a file named datamodelgen with the following content :

With # Means a comment line

version = <user choosen integer version>
author = <a string of the author>

displayer.namespace = <displayer side simple namespace name where to generate code>
authority.namespace = <authority side simple namespace name where to generate code>
editor.namespace = <editor side simple namespace name where to generate code>

hppext = <file extension for headers files>
cppext = <file extension for sources files>
input = <input folder containing the data model files, path is relative to its file>

displayer.output = <on displayer, output folder, where to generate the code, headers and sources, relative to this>
authority.output = <on authority, output folder, where to generate the code, headers and sources, relative to this>
editor.output = <on editor, output folder, where to generate the code, headers and sources, relative to this>

# distinct output folders for each target (replace <target> by one of the three)
<target>.output.headers = <on target, output folder, where to generate the code, headers only, relative to this>
<target>.output.sources = <on target, output folder, where to generate the code, sources only, relative to this>
<target>.output.includes = <path where to find the generated headers, can be relative>

templates = <folder where to find templates files, relative to this>
export = <displayer|authority|editor|any meaning export only for displayer, for authority, for editor or for the three>
